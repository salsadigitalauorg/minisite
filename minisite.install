<?php

/**
 * @file
 * Contains install and update functions for Minisite.
 */

use Drupal\Core\Database\Database;
use Drupal\Core\File\FileSystemInterface;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\minisite\Minisite;

/**
 * Implements hook_uninstall().
 */
function minisite_uninstall() {
  // Remove the minisite directory and generated files.
  if (file_exists(Minisite::getCommonArchiveDir())) {
    \Drupal::service('file_system')->deleteRecursive(Minisite::getCommonArchiveDir());
  }
  if (file_exists(Minisite::getCommonAssetDir())) {
    \Drupal::service('file_system')->deleteRecursive(Minisite::getCommonAssetDir());
  }
}

/**
 * Implements hook_requirements().
 */
function minisite_requirements($phase) {
  if ($phase != 'runtime') {
    return [];
  }

  $requirements = [];

  if ($phase == 'runtime') {
    $path = Minisite::getCommonArchiveDir();
    $requirements['minisite_archive'] = [
      'title' => t('Minisite archive files upload directory'),
      'severity' => REQUIREMENT_OK,
      'value' => t('Exists (%path)', ['%path' => $path]),
    ];
    if (!\Drupal::service('file_system')->prepareDirectory($path, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS)) {
      $requirements['minisite_archive']['description'] = t('The Minisite archive upload directory %path could not be created due to a misconfiguration of files directory. Please ensure that the files directory is correctly configured and that the webserver has permission to create directories.', [
        '%path' => file_uri_target($path),
      ]);
      $requirements['minisite_archive']['severity'] = REQUIREMENT_ERROR;
      $requirements['minisite_archive']['value'] = t('Unable to create');
    }

    $path = Minisite::getCommonAssetDir();
    $requirements['minisite_asset'] = [
      'title' => t('Minisite asset files directory'),
      'severity' => REQUIREMENT_OK,
      'value' => t('Exists (%path)', ['%path' => $path]),
    ];
    if (!\Drupal::service('file_system')->prepareDirectory($path, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS)) {
      $requirements['minisite_asset']['description'] = t('The Minisite asset files directory %path could not be created due to a misconfiguration of files directory. Please ensure that the files directory is correctly configured and that the webserver has permission to create directories.', [
        '%path' => file_uri_target($path),
      ]);
      $requirements['minisite_asset']['severity'] = REQUIREMENT_ERROR;
      $requirements['minisite_asset']['value'] = t('Unable to create');
    }

    $requirements['minisite_archiver'] = [
      'title' => t('Minisite archiver library'),
      'severity' => REQUIREMENT_OK,
      'value' => t('Present'),
    ];
    if (!class_exists(\ZipArchive::class)) {
      $requirements['minisite_archiver']['description'] = t('ZipArchive is required to extract Minisite assets from uploaded archives. Please install php-zip extension.');
      $requirements['minisite_asset']['severity'] = REQUIREMENT_ERROR;
      $requirements['minisite_asset']['value'] = t('Absent');
    }
  }

  return $requirements;
}

/**
 * Implements hook_schema().
 */
function minisite_schema() {
  $schema['minisite_asset'] = [
    'description' => 'Asset information for minisite.',
    'fields' => [
      'id' => [
        'description' => 'The primary identifier for a minisite asset',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ],
      'entity_type' => [
        'description' => 'The entity type of that entity.',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => '',
      ],
      'entity_bundle' => [
        'description' => 'The type of this entity.',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => '',
      ],
      'entity_id' => [
        'description' => 'The entity id this data is attached to',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ],
      'entity_language' => [
        'description' => 'The {language}.langcode of this entity.',
        'type' => 'varchar_ascii',
        'length' => 12,
        'not null' => TRUE,
        'default' => '',
      ],
      'field_name' => [
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => '',
      ],
      'source' => [
        'description' => 'The URI of the source asset file.',
        'type' => 'varchar',
        'length' => 2048,
        'not null' => TRUE,
        'default' => '',
      ],
      'alias' => [
        'description' => 'The alias for the asset path.',
        'type' => 'varchar',
        'length' => 2048,
        'not null' => FALSE,
        'default' => '',
      ],
      'filemime' => [
        'description' => 'The file MIME of the asset.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'default' => NULL,
      ],
      'filesize' => [
        'description' => 'The file size of the asset.',
        'type' => 'int',
        'size' => 'big',
        'length' => 20,
        'unsigned' => TRUE,
        'not null' => FALSE,
        'default' => NULL,
      ],
    ],
    'primary key' => [
      'id',
    ],
    'unique keys' => [
      'id' => [
        'id',
        'entity_type',
        'entity_bundle',
        'entity_id',
        'entity_language',
        'field_name',
      ],
    ],
    'indexes' => [
      'source' => [['source', 170]],
      'alias' => [['alias', 170]],
    ],
  ];

  return $schema;
}

/**
 * Adds 'filemime' and 'filesize' and removes `entity_rid` columns.
 */
function minisite_update_8001() {
  $schema = Database::getConnection()->schema();

  $spec = [
    'description' => 'The file MIME of the asset.',
    'type' => 'varchar',
    'length' => 255,
    'not null' => FALSE,
    'default' => NULL,
  ];
  $schema->addField('minisite_asset', 'filemime', $spec);

  $spec = [
    'description' => 'The file size of the asset.',
    'type' => 'int',
    'size' => 'big',
    'length' => 20,
    'unsigned' => TRUE,
    'not null' => FALSE,
    'default' => NULL,
  ];
  $schema->addField('minisite_asset', 'filesize', $spec);

  $schema->dropField('minisite_asset', 'entity_rid');
}

/**
 * Updates mime type and file size DB records for all Minisite assets.
 */
function minisite_update_8013(&$sandbox) {
  $batch_size = 10;

  if (!isset($sandbox['current_minisite_field_id'])) {
    $minisite_field_ids = [];

    // Get all the entity reference revisions fields.
    $map = \Drupal::service('entity_field.manager')->getFieldMapByFieldType('minisite');
    foreach ($map as $entity_type_id => $info) {
      foreach ($info as $name => $data) {
        if (FieldStorageConfig::loadByName($entity_type_id, $name)->getSetting('target_type') == 'file') {
          $minisite_field_ids[] = "$entity_type_id.$name";
        }
      }
    }

    if (!$minisite_field_ids) {
      // There are no minisite fields. Return before initializing the sandbox.
      return;
    }

    // Initialize the sandbox.
    $sandbox['current_minisite_field_id'] = 0;
    $sandbox['minisite_field_ids'] = $minisite_field_ids;
    $sandbox['max'] = count($minisite_field_ids);
    $sandbox['progress'] = 0;
    $sandbox['updated'] = 0;
  }

  /** @var \Drupal\field\FieldStorageConfigInterface $field_storage */
  $field_storage = FieldStorageConfig::load($sandbox['minisite_field_ids'][$sandbox['current_minisite_field_id']]);

  $target_entity_type = \Drupal::entityTypeManager()->getDefinition($field_storage->getTargetEntityTypeId());

  $id = $target_entity_type->getKey('id');
  $entity_ids = \Drupal::entityQuery($field_storage->getTargetEntityTypeId())
    ->condition($field_storage->getName(), NULL, 'IS NOT NULL')
    ->range($sandbox['progress'], $batch_size)
    ->sort($id, 'ASC')
    ->accessCheck(FALSE)
    ->execute();

  foreach ($entity_ids as $entity_id) {
    $host_entity = \Drupal::entityTypeManager()
      ->getStorage($field_storage->getTargetEntityTypeId())
      ->load($entity_id);

    $field_item_list = $host_entity->get($field_storage->getName());
    $minisite = Minisite::createInstance($field_item_list);

    if ($minisite) {
      $minisite->save();
      $sandbox['updated']++;
    }
  }

  if (count($entity_ids) < $batch_size) {
    $sandbox['current_minisite_field_id']++;
    $sandbox['progress'] = 0;
  }
  else {
    $sandbox['progress'] += $batch_size;
  }
  // Update #finished, 1 if the the whole update has finished.
  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['current_minisite_field_id'] / $sandbox['max']);

  if ($sandbox['#finished'] < 1) {
    return t('Processed @processed of @total and updated @updated assets', [
      '@total' => $sandbox['max'],
      '@processed' => $sandbox['progress'],
      '@updated' => $sandbox['updated'],
    ]);
  }
}
