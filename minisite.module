<?php

/**
 * @file
 * Main functions of the Minisite module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\file\FileInterface;
use Drupal\minisite\AssetInterface;
use Drupal\minisite\Exception\ArchiveException;
use Drupal\minisite\Minisite;

require_once dirname(__FILE__) . '/minisite.theme.inc';

/**
 * Implements hook_help().
 */
function minisite_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.minisite':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Upload and serve arbitrary "minisites" archives from a Drupal website.') . '</p>';

      $output .= '<h3>' . t('Archives') . '</h3>';
      $output .= '<p>' . t('Supported archives are <code>@archives</code>.', ['@archives' => implode(', ', Minisite::supportedArchiveExtensions())]) . '</p>';

      $output .= '<p>' . t('Archive must abide by the following constraints:') . '</p>';
      $output .= '<ul>';
      $output .= '  <li>' . t('Must contain only one top-level directory.') . '</li>';
      $output .= '  <li>' . t('Must contain only files with extensions from the allowed list (configured for each field).') . '</li>';
      $output .= '  <li>' . t('Must contain <code>@index</code> page under topmost root directory.', ['@index' => AssetInterface::INDEX_FILE]) . '</li>';
      $output .= '  <li>' . t('Should contain pages with relative links.') . '</li>';
      $output .= '</ul>';

      $output .= '<h3>' . t('URL rewrite') . '</h3>';
      $output .= '<p>' . t('When a minisite is served through aliased URL, the internal links are rewritten based on the following rules:') . '</p>';
      $output .= '<ul>';

      $output .= '  <li>';
      $output .= '    <p>' . t('For <code>&lt;a&gt;</code> tag:') . '</p>';
      $output .= '    <ul>';
      $output .= '      <li>' . t('If link is external, do not alter it.') . '</li>';
      $output .= '      <li>' . t('If link is to the HTML document and relative to root (starts with <code>./</code> or <code>/</code>), rewrite it to point to the aliased path.') . '</li>';
      $output .= '      <li>' . t('If link is to the HTML document and relative to other documents (starts with <code>../</code>), rewrite it to always point to the aliased path.') . '</li>';
      $output .= '      <li>' . t('If link is to the non-HTML file, rewrite it to always point to the expanded file in the filesystem.') . '</li>';
      $output .= '    </ul>';
      $output .= '  </li>';

      $output .= '  <li>';
      $output .= '    <p>' . t('For <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code> and <code>&lt;img&gt;</code> tags:') . '</p>';
      $output .= '    <ul>';
      $output .= '      <li>' . t('If link is external, do not alter it.') . '</li>';
      $output .= '      <li>' . t('All other types of links are rewritten to always point to the expanded file in the filesystem.') . '</li>';
      $output .= '    </ul>';
      $output .= '  </li>';

      $output .= '  <li>' . t('The <code>&lt;base&gt;</code> tag in <code>&lt;head&gt;</code> is always removed.') . '</li>';
      $output .= '</ul>';

      return $output;
  }
}

/**
 * Validation callback.
 *
 * @param \Drupal\file\FileInterface $file
 *   The file to validate.
 * @param string $content_extensions
 *   String list of the allowed archive content extensions.
 *
 * @return array
 *   Array of errors, if any.
 */
function minisite_validate_archive(FileInterface $file, $content_extensions) {
  $errors = [];

  try {
    Minisite::validateArchive($file, $content_extensions);
  }
  catch (ArchiveException $exception) {
    $errors[] = $exception->getMessage();
  }
  catch (\Exception $exception) {
    $errors[] = t('Unable to use uploaded file as a Minisite');
  }

  return $errors;
}

/**
 * Implements hook_entity_delete().
 */
function minisite_entity_delete(EntityInterface $entity) {
  if (!$entity instanceof FieldableEntityInterface) {
    return;
  }

  /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager */
  $entity_field_manager = Drupal::service('entity_field.manager');
  /** @var \Drupal\Core\Field\FieldDefinitionInterface[] $minisite_fields */
  $minisite_fields = array_filter($entity_field_manager->getFieldDefinitions($entity->getEntityTypeId(), $entity->bundle()), function (FieldDefinitionInterface $field_definition) {
    return $field_definition->getType() == 'minisite';
  });

  /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
  foreach ($minisite_fields as $minisite_field) {
    if ($entity->hasField($minisite_field->getName())) {
      $minisite = Minisite::createInstance($entity->{$minisite_field->getName()});
      if ($minisite) {
        $minisite->delete();
      }
    }
  }
}
