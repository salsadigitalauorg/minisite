<?php

/**
 * @file
 * Main functions of the Minisite module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Url;
use Drupal\file\FileInterface;
use Drupal\minisite\AssetInterface;
use Drupal\minisite\Exception\ArchiveException;
use Drupal\minisite\Minisite;

require_once dirname(__FILE__) . '/minisite.theme.inc';

/**
 * Implements hook_help().
 */
function minisite_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.minisite':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Used to upload and run self contained structured but static content as "mini websites".') . '</p>';

      $output .= '<h3>' . t('Archives') . '</h3>';
      $output .= '<p>' . t('Supported archive files are <code>@archives</code>.', ['@archives' => implode(', ', Minisite::supportedArchiveExtensions())]) . '</p>';

      $output .= '<p>' . t('Archives must abide by the following constraints:') . '</p>';
      $output .= '<ul>';
      $output .= '  <li>' . t('Must contain only one top-level directory.') . '</li>';
      $output .= '  <li>' . t('Must contain only files with extensions from the "allowed list" (configured for each field).') . '</li>';
      $output .= '  <li>' . t('Must contain <code>@index</code> page under topmost root directory.', ['@index' => AssetInterface::INDEX_FILE]) . '</li>';
      $output .= '  <li>' . t('Should contain pages with relative links.') . '</li>';
      $output .= '</ul>';

      $output .= '<h3>' . t('URL rewrite (alias)') . '</h3>';
      $output .= '<p>' . t('Applies when the "Use alias" option is selected after a mini-site archive is uploaded.</p>');
      $output .= '<p>' . t('A mini-site served through an aliased URL updates internal links that are rewritten based on the following rules:') . '</p>';

      $output .= '<ul>';

      $output .= '  <li>';
      $output .= '    <p>' . t('For <code>&lt;a&gt;</code> tag:') . '</p>';
      $output .= '    <ul>';
      $output .= '      <li>' . t('If link is external, do not alter it.') . '</li>';
      $output .= '      <li>' . t('If link is to the HTML document and relative to root (starts with <code>./</code> or <code>/</code>), rewrite it to point to the aliased path.') . '</li>';
      $output .= '      <li>' . t('If link is to the HTML document and relative to other documents (starts with <code>../</code>), rewrite it to always point to the aliased path.') . '</li>';
      $output .= '      <li>' . t('If link is to the non-HTML file, rewrite it to always point to the expanded file in the file system.') . '</li>';
      $output .= '    </ul>';
      $output .= '  </li>';

      $output .= '  <li>';
      $output .= '    <p>' . t('For <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code> and <code>&lt;img&gt;</code> tags:') . '</p>';
      $output .= '    <ul>';
      $output .= '      <li>' . t('If link is external, do not alter it.') . '</li>';
      $output .= '      <li>' . t('All other types of links are rewritten to always point to the expanded file in the file system.') . '</li>';
      $output .= '    </ul>';
      $output .= '  </li>';

      $output .= '  <li>' . t('The <code>&lt;base&gt;</code> tag in <code>&lt;head&gt;</code> is always removed.') . '</li>';
      $output .= '</ul>';

      return $output;
  }
}

/**
 * Validation callback.
 *
 * @param \Drupal\file\FileInterface $file
 *   The file to validate.
 * @param string $content_extensions
 *   String list of the allowed archive content extensions.
 *
 * @return array
 *   Array of errors, if any.
 */
function minisite_validate_archive(FileInterface $file, $content_extensions) {
  $errors = [];

  try {
    Minisite::validateArchive($file, $content_extensions);
  }
  catch (ArchiveException $exception) {
    $errors[] = $exception->getMessage();
  }
  catch (\Exception $exception) {
    $errors[] = t('Unable to use uploaded file as a Minisite');
  }

  return $errors;
}

/**
 * Implements hook_path_insert().
 */
function minisite_path_insert($path) {
  $params = Url::fromUri("internal:" . $path['source'])->getRouteParameters();
  $entity_type = key($params);
  $entity = \Drupal::entityTypeManager()->getStorage($entity_type)->load($params[$entity_type]);

  if ($entity) {
    /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager */
    $entity_field_manager = Drupal::service('entity_field.manager');
    /** @var \Drupal\Core\Field\FieldDefinitionInterface[] $minisite_fields */
    $minisite_fields = array_filter($entity_field_manager->getFieldDefinitions($entity->getEntityTypeId(), $entity->bundle()), function (FieldDefinitionInterface $field_definition) {
      return $field_definition->getType() == 'minisite';
    });

    /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
    foreach ($minisite_fields as $minisite_field) {
      if ($entity->hasField($minisite_field->getName())) {
        $minisite = Minisite::createInstance($entity->{$minisite_field->getName()});
        if ($minisite) {
          $minisite->setAlias($path['alias']);
          $minisite->save();
        }
      }
    }
  }
}

/**
 * Implements hook_path_update().
 */
function minisite_path_update($path) {
  $params = Url::fromUri("internal:" . $path['source'])->getRouteParameters();
  $entity_type = key($params);
  $entity = \Drupal::entityTypeManager()->getStorage($entity_type)->load($params[$entity_type]);

  if ($entity) {
    /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager */
    $entity_field_manager = Drupal::service('entity_field.manager');
    /** @var \Drupal\Core\Field\FieldDefinitionInterface[] $minisite_fields */
    $minisite_fields = array_filter($entity_field_manager->getFieldDefinitions($entity->getEntityTypeId(), $entity->bundle()), function (FieldDefinitionInterface $field_definition) {
      return $field_definition->getType() == 'minisite';
    });

    /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
    foreach ($minisite_fields as $minisite_field) {
      if ($entity->hasField($minisite_field->getName())) {
        $minisite = Minisite::createInstance($entity->{$minisite_field->getName()});
        if ($minisite) {
          $minisite->setAlias($path['alias']);
          $minisite->save();
        }
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function minisite_entity_delete(EntityInterface $entity) {
  if (!$entity instanceof FieldableEntityInterface) {
    return;
  }

  /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager */
  $entity_field_manager = Drupal::service('entity_field.manager');
  /** @var \Drupal\Core\Field\FieldDefinitionInterface[] $minisite_fields */
  $minisite_fields = array_filter($entity_field_manager->getFieldDefinitions($entity->getEntityTypeId(), $entity->bundle()), function (FieldDefinitionInterface $field_definition) {
    return $field_definition->getType() == 'minisite';
  });

  /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
  foreach ($minisite_fields as $minisite_field) {
    if ($entity->hasField($minisite_field->getName())) {
      $minisite = Minisite::createInstance($entity->{$minisite_field->getName()});
      if ($minisite) {
        $minisite->delete();
      }
    }
  }
}
