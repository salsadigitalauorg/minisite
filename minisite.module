<?php

/**
 * @file minisite.module
 * Module file.
 */

define('MINISITE_UPLOADPATH', 'minisite/upload');
define('MINISITE_ASSETPATH', 'minisite/static');
define('MINISITE_EXTENSIONS_WHITELIST', 'html htm js css png jpg gif svg pdf doc docx ppt pptx xls xlsx tif xml txt woff woff2 ttf eot');
define('MINISITE_EXTENSIONS_BLACKLIST', 'exe scr bmp');
define('MINISITE_EXTENSIONS_NOREWRITE', 'pdf doc docx ppt pptx xls xlsx tif xml txt');
define('MINISITE_MAXFILESIZE', file_upload_max_size());
define('MINISITE_HASHSALT', 'minisite');

// Load all Field module hooks for Minisite.
require_once dirname(__FILE__) . '/includes/minisite.field.inc';
// Load all theme hooks for Minisite.
require_once dirname(__FILE__) . '/includes/minisite.theme.inc';

/**
 * Implements hook_help().
 */
function minisite_help($path, $arg) {
  switch ($path) {
    case 'admin/help#minisite':
      $output = '<p>' . t("Provides the ability to upload arbitrary 'minisites' to a Drupal website.") . '</p>';
      return $output;
  }
}

/**
 * Exact minisite files.
 * @param \stdClass $file
 * @param $minisite_extract_path
 */
function minisite_site_extract(stdClass $file, $minisite_extract_path = MINISITE_ASSETPATH) {
  $archive = MinisiteArchive::open($file);
  $archive->extract('public://' . $minisite_extract_path);
}

/**
 * Load minisite.
 */
function minisite_site_load() {
  $view_mode = FALSE;

  $path = current_path();
  if (strpos($path, 'node/') === FALSE) {
    $segments = explode('/', $path);
    foreach ($segments as $k => $segment) {
      $internal = drupal_get_normal_path($segment);
      if (strpos($internal, 'node/') !== FALSE) {
        $path = $internal;
        $view_mode = 'full';
        break;
      }
    }
  }

  $entity = menu_get_object('node', 1, $path);
  return array($entity, $view_mode);
}

/**
 * Build minisite.
 */
function minisite_site_build($entity) {
  list($resource, $minisite_realurl, $minisite_pathalias) = minisite_site_paths_info($entity);
  $html = minisite_site_parse($entity);

  return $html;
}

/**
 * Return minisite paths information.
 * @param $entity
 * @return array
 */
function minisite_site_paths_info($entity) {
  // Prepare minisite path and alias.
  global $base_url;

  // Load module inc file.
  module_load_include('inc', 'minisite', 'includes/minisite.func');

  $minisite_field_name = minisite_site_field_with_bundle($entity->type);
  $wrapper = entity_metadata_wrapper('node', $entity);
  $minisite_field_values = $wrapper->$minisite_field_name->value();
  $minisite_basepath = $minisite_field_values['basepath'];
  $minisite_nodepath = 'node/' . $entity->nid;
  $minisite_pathalias = drupal_get_path_alias($minisite_nodepath);

  $minisite_realurl = $base_url . '/' . variable_get('file_public_path', conf_path() . '/files/') . $minisite_basepath . '/';
  $request_path = request_path();
  $request_path = substr(urldecode($request_path), strlen($minisite_pathalias) + 1);
  if (empty($request_path) || $request_path == '/') {
    $request_path = 'index.html';
  }

  $resource = 'public://' . $minisite_basepath . '/' . $request_path;

  return array(
    $resource,
    $minisite_realurl,
    $minisite_pathalias,
  );
}

/**
 * Parse minisite.
 * @param $resource
 * @return string
 */
function minisite_site_parse($entity) {
  list($resource, $minisite_realurl, $minisite_pathalias) = minisite_site_paths_info($entity);

  // Bypass lib error.
  libxml_use_internal_errors(TRUE);

  $document = new DOMDocument;
  $document->loadHTMLFile($resource);

  // Return 404 if document is empty.
  if (empty($document)) {
    return drupal_not_found();
  }

  $head = $document->getElementsByTagName('head')->item(0);
  // Return 404 is document head is empty.
  if (empty($head)) {
    return drupal_not_found();
  }
  if ($head->hasChildNodes()) {
    // Update base href.
    $base = $document->createElement('base');
    $base->setAttribute('href', $minisite_realurl);
    $head->insertBefore($base, $head->firstChild);
  }
  else {
    $head->appendChild($base);
  }

  // Update relative URL.
  foreach ($document->getElementsByTagName('a') as $item) {
    $href = $item->getAttribute('href');
    // Keep absolute URL.
    if (parse_url($href, PHP_URL_SCHEME) != '') {
      continue;
    }
    // If href starts with . or ..
    if (substr($href, 0) == '.' || substr($href, 0, 2) == '..' || substr($href, 0) == '/') {
      continue;
    }
    $regex = '/\.(' . preg_replace('/ +/', '|', preg_quote(MINISITE_EXTENSIONS_NOREWRITE)) . ')$/i';
    if (preg_match($regex, $href)) {
      continue;
    }

    $item->setAttribute('href', '/' . $minisite_pathalias . '/' . $href);
  }

  $html = $document->saveHTML();

  return $html;
}

/**
 * Return minisite site path.
 * @param \stdClass $file
 * @return array
 */
function minisite_site_file_path_info(stdClass $file) {
  if (empty($file)) {
    return FALSE;
  }

  $minisite_hash = minisite_site_hash($file->filename);
  $minisite_path = MINISITE_ASSETPATH . '/' . $minisite_hash;

  $archive = MinisiteArchive::open($file);
  $tree = $archive->filesTree();
  // Ignore __MACOSX folder.
  unset($tree['__MACOSX']);

  $root_files = array_keys($tree);
  $top_folder = $root_files[0];

  return array(
    $minisite_path,
    $minisite_path . '/' . $top_folder,
  );
}

/**
 * Generate minisite site hash.
 * @param $data
 * @return string
 */
function minisite_site_hash($data) {
  return drupal_hmac_base64($data, MINISITE_HASHSALT);
}

/**
 * Return minisite file extensions blacklist.
 * @return array
 */
function minisite_site_extensions_blacklist() {
  $extensions_blacklist =  &drupal_static(__FUNCTION__);

  if (!isset($extensions_blacklist)) {
    $extensions_blacklist = preg_replace('/([, ]+\.?)/', ' ', trim(strtolower(MINISITE_EXTENSIONS_BLACKLIST)));
    $extensions_blacklist = array_filter(explode(' ', $extensions_blacklist));
    $extensions_blacklist = array_unique($extensions_blacklist);
  }

  return $extensions_blacklist;
}
